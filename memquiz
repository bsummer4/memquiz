#!/usr/bin/env tclsh8.5

# Usage:
#
#     memquiz quiz-file
#
# How it works:
#
# 1. Show a question
# 2. Wait for some input (any input)
# 3. Show the answer
# 4. goto 1

set l [list]

proc empty str { expr {![string length [string trim $str]]} }

proc add {x y} {
    lappend ::l [list [string trim $x] [string trim $y]] }

proc quiz {} {}
proc usage {} { puts stderr "Usage: $::argv0 card-spec"; exit 1 }
switch [llength $argv] {
	2 {
		set infile [lindex $argv 1]
		set reverse 1
		if {![string equal -r [lindex $argv 0]]} usage }
	1 {
		set infile [lindex $argv 0]
		set reverse 0 }
	default usage }
set in [open $infile]

set front [list]
set back [list]
set v front
while {![eof $in]} {
    gets $in line
    switch -regexp -- $line {
        :: { regexp {^([^:]*)::(.*)$} $line -- a b
             if {[string equal $v back]} { set back "$back $line"; continue }
             if {![empty $a]} { set front "$front [string trim $a]" }
             if {![empty $b]} { set back "$back [string trim $b]" }
             set v back
             continue }
        {^%%$} { set v front;
                 add $front $back; 
                 set front {};
                 set back {}; 
                 continue }
        default { set $v "[set $v] $line" }}}

set ::recent [list]
set x [expr [llength $::l] / 3]
proc getpair {} {
	while 1 {
		set index [expr "int(rand()*[llength $::l])"]
		if {-1 == [lsearch -integer $::recent $index]} {
			lappend ::recent $index
			if {[llength $::recent] > $::x} {
				set ::recent [lrange $::recent 1 end] }
			break }}
	set r [lindex $::l $index]
	if {$::reverse} {return [lreverse $r]}
	return $r }

proc newline {} { puts {} }
proc bar {} { puts {==================}}

while 1 {
	set pair [getpair]
	newline
	newline; bar
	puts [lindex $pair 0]
	gets stdin
	puts "    [lindex $pair 1]" }
